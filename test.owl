#using owl.v4

# type identifiers use upper-case
.token type_ident
.whitespace ' ' '\t'

program = _ (stmt{line, 1+} _)?

stmt = "pub"? base_stmt

base_stmt =
  'let' _ binding (':' _ type_expr)? _ '=' _ expr : let
  'return' expr? : return
  'for' _ binding _ 'in' _ expr block : for
  'while' _ expr block : while
  'continue' : continue
  'break' : break
  'func' _ identifier type_params? func_params block : func
  'type' _ type_binding _ '=' _ type_expr : type
  'enum' _ type_binding enum_body : enum
  'struct' _ type_binding type_body : struct
  'impl' _ type_params? type_expr _ 'for' _ type_expr type_body
  'module' _ type_ident block? : module
  'import' _ import_path (_ "from" _ string@package)? : import
  expr : expr

func_params =
  ['(' _ (func_param{',' _, 1+} ','? _)? ')']
func_param =
  identifier ':' type_expr

enum_body =
  ['{' _ (enum_case{line, 1+} _)? '}'] 
enum_case =
  'case' type_ident type_body?

import_path_tree =
  import_path : module_or_type
  mod_value : value

import_path =
  mod_type : simple
  mod_type "as" type_ident : renamed
  mod_type "::" ["{" _ (import_path_tree{',' _, 1+} ','? _) "}"] : tree
  
expr =
  'if' _ if_cond block (_ 'else' 'if' _ if_cond block)* (_ 'else' block)? : if
  'match' _ base_expr match_block : match
  base_expr : expr

if_cond =
  'let' binding (':' type_expr)? '=' base_expr : if_let
  base_expr : if_expr  

match_block =
  ['{' _ (match_case{line, 1+} _)? '}']
match_case =
  'case' binding block

base_expr =
  [ '(' _ expr _ ')' ] : parens
  mod_value : ident
  number : number
  string : string
  ['{' '|' _ (binding{"," _, 1+} _)? '|' program '}'] : closure
  tuple : tuple
  type_ident (tuple | record)? : constructor
  block : block
.operators postfix
  args : funcall
  _ "." mod_value args : dotcall
  _ ":" (string | number) : field
  _ "as" type_expr : type_as
.operators prefix
  '-' : negate
  '!' : not
.operators infix right
  '**' : pow
.operators infix left
  '*' : mult
  '/' : div
.operators infix left
  '+' : add
  '-' : sub
.operators infix left
  '==' : eq
  '!=' : neq
  '<' : lt
  '>' : gt
  '<=' : lte
  '>=' : gte
.operators infix left
  '&&' : and
.operators infix left
  '||' : or
.operators infix right
  '=' : assign

binding =
  base_binding ('as' identifier)?
bind_field =
  identifier : field_pun
  identifier ':' base_binding ('as' identifier)? : field
base_binding =
  identifier : identifier
  mod_type? ['[' binding{','} ']'] : tuple
  mod_type? ['{' bind_field{','} '}'] : record

type_param =
  type_ident (':' type_expr{'&'})?

type_expr =
  mod_type type_args?


# module-qualified identifiers

mod_type =
  (type_ident '::')* type_ident
mod_value =
  (type_ident '::')* identifier

# utilities

args =
  ['(' expr{','} ')']
type_args =
  ['[' type_expr{','} ']']
tuple = 
  ['[' expr{','} ']']
record = 
  ['{' (identifier ':' expr){','} '}']
block = 
  ['{' program '}']

# type utilities

type_binding =
  type_ident type_params?
type_params =
  ['[' type_param{','} ']']
type_body =
  ['[' type_expr{','} ']'] : tuple
  ['{' (identifier ':' type_expr){','} '}'] : record

line = newline | ';'
_ = '\n'*
newline = '\n'+
